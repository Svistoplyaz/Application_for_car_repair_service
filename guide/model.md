
# Руководство программиста

Проект представляет собой десктопное приложение, разработанное на Java и использующее встраиваемую СУБД [SQLite] для хранения данных. В качестве зависимостей используются следующие библиотеки:
- [org.xerial:sqlite-jdbc:3.21.0.1](https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc/3.21.0.1) - библиотека SQLite для JDBC (Java DataBase Connectivity);
- [org.apache.commons:commons-lang3:3.0](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3/3.0) - набор утилит, расширяющих возможности стандартной библиотеки Java;
- [io.github.lzh0379:jdatepicker:2.0.3](https://mvnrepository.com/artifact/io.github.lzh0379/jdatepicker/2.0.3) - компоненты Java Swing для выбора даты;
- [com.intellij:annotations:12.0](https://mvnrepository.com/artifact/com.intellij/annotations/12.0) - аннотации для интеграции инспекций кода с [IntelliJ IDEA].

Все зависимости автоматически загружаются средой разработки из репозитория [Maven](https://maven.apache.org/) в папку `.m2`.

[SQLite]: https://www.sqlite.org/index.html
[IntelliJ IDEA]: http://www.jetbrains.com/idea/

#### Сборка проекта

Структура проекта построена для разработки и сборки с использованием IDE [IntelliJ IDEA]. Для открытия проекта необходимо в соответствующем меню (`File > Open`) выбрать корневую папку склонированного репозитория.

Для получения проекта в виде независимого jar файла необходимо выполнить сборку проекта (`Build > Build Project`), после чего исполняемый файл будет доступен по пути `out/artifacts/application/application.jar`.

#### Логическая структура проекта

Программная часть реализованного приложения логически разбита на две основные части - работа с моделью данных и их хранилищем, а также пользовательский интерфейс, каждая из которых может быть рассмотрена отдельно.

## Модель данных и их хранилище

Данная часть разработанного приложения предоставляет интерфейс для работы с базой данных напрямую, а также содержит простейшую реализацию [ORM](https://ru.wikipedia.org/wiki/ORM) (объектно-реляционного отображения), которое позволяет при разработке пользовательского интерфейса работать с объетами языка программирования Java как с сущностями предметной области, не задумываясь о деталях реализации их хранения в базе данных.

Основные классы `Database` и `Model` находятся в пакете `net.web_kot.teamdev.db`, вложенный пакет `entities` содержит класс абстрактной сущности `AbstractEntity`, а также по классу на каждую сущность, работа с которой возможна из пользовательского интерфейса.

### Создание подключения к базе данных и её инициализация

Для создания интерфейса для работы и подключения к базе данных, использующей файл `storage.db` для хранения данных, необходимо вызвать конструктор с необходимым параметром:

```Java
Database database = new Database(new File("storage.db"));
```

Класс `Database` попробует осуществить подключение к данному файлу, используя драйвер SQLite. После чего выполнит активацию поддержки внешних ключей и выполнит запросы, содержащиеся в файле ресурсов `init.sql`, которые отвечают за создание таблиц базы данных и внесение в них начальных значений. Запросы должны быть написаны с учетом того, что они выполняются при каждом подключении, например, создание таблиц должно содержать условие `IF NOT EXISTS`. Отдельные запросы должны быть отделены друг от друга специальным разделителем - отдельной строкой, содержащей `---`.

Пример двух разделенных запросов:

```SQL
CREATE TABLE IF NOT EXISTS Clients (
  PK_Clients INTEGER PRIMARY KEY NOT NULL,
  Name TEXT(100) NOT NULL,
  Phone TEXT(12)
);

---

CREATE TABLE IF NOT EXISTS Service (
  PK_Service INTEGER PRIMARY KEY NOT NULL,
  Name TEXT(50) NOT NULL
);
```

Для включения режима отладки с отображением на стандартный поток вывода всех выполняющихся запросов, необходимо вызвать метод `setDebug(true)` у объекта класса `Database`.

### Форматирование запросов

Для упрощения форматирования запросов у класса `Database` предусмотрен метод `formatQuery(String, Object...)`. Он принимает на вход шаблон SQL-запроса, содержащий спецификации (например, `%d` для чисел или `%s` для строк), и осуществляет замену этих спецификаций на последующие переданные параметры (внутри используется [`Formatter`](https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html) и доступны все его возможности). Также дополнительно производится обертка параметров:
- все `null` объекты подставляются в запрос как `NULL` (обязательно использование спецификации `%s`);
- аргументы типа `String` заключаются в двойные кавычки, содержащиеся в строке кавычки удаляются, удаляются ведущие и концевые пробельные символы.

На выходе данный метод возвращает отформатированную строку, которая может дальше быть передана в запросы. Стандартные методы выполнения запросов в `Database` имеют встроенную поддержку форматирования.

```Java
database.formatQuery(
  "INSERT INTO Table (str1, str2, int1, int2) VALUES (%s, %s, %s, %d)",
  " qwer\"ty", null, Integer.valueOf(10), 12
)
```
```SQL
INSERT INTO Table (str1, str2, int1, int2) VALUES ("qwerty", NULL, 10, 12)
```

### Выполнение запросов

Для выполнения запросов предусмотрены несколько методов, отличающихся возвращаемыми данными, их аргументы совпадают с `formatQuery`. В случае возникновения ошибки при выполнении запроса выбрасывается `SQLException`.
- `exec` - запросы, которые не предусматривают возврат результата;
- `insert` - вставка данных, возвращает идентификатор последней созданной записи;
- `update` - обновление данных, возвращает количество модифицированных записей;
- `select` - получение данных, возвращает [ResultSet](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html).

Примеры выполнения запросов:
```Java
id = database.insert(
  "INSERT INTO Model (Name, Year, PK_Mark) VALUES (%s, %d, %d)",
  name, year, markId
);
```
```Java
ResultSet result = database.select("SELECT * FROM Status WHERE PK_Order = %d ORDER BY PK_Status ASC", id);
```
```Java
database.exec("DELETE FROM %s WHERE %s = %d", tableName, primaryKey, id);
```

### Модель данных

Основным классом, отвечающим за работу с моделью данных, являтся `Model`. Доступ к объекту данного класса, связанного с определенной базой данных, можно получить с использованием метода `getModel` объекта базы. Данный класс предназначен для доступа к методам для работы с объектами конкретных сущностей базы данных. Из объекта модели можно получить доступ к базе данных для выполнения запросов с использованием метода `db`.

Также он содержит метод `List<T> getList(Class<T>, String)`, который позволят получить список объектов класса `T`, соответствующих записям, полученным в запросе `SELECT`, переданном вторым параметром (встроенное форматирование отсутствует). Класс `T` обязательно должен наследовать `AbstractEntity` и содержать конструктор с аннотацией `@SelectConstructor`. Данный конструктор должен первым параметром принимать `Model`, а порядок и типы последующих параметров должны соответствовать значениям, которые будут возвращены запросом для каждой записи. В случае, если могут быть возращены числовые поля со значением `NULL`, в конструкторе должны в качестве аргуметов использоваться классы `Integer` и `Long` вместо `int` и `long`.

Примеры описания конструктора и выполнения запроса:
```Java
@SelectConstructor
public Client(Model model, int id, String name, String phone) { ... }
```
```Java
List<Client> clients = getList(Client.class, "SELECT PK_Clients, Name, Phone FROM Clients");
```

#### Абстрактная сущность

Каждый класс модели должен наследовать `AbstractEntity`. Конструктор данного класса принимает `Model`, название таблицы и ее первичного ключа для данной сущности. Из наследующих классов доступны `protected` поля `model` и `id`, которые являются переданной в конструктор моделью и местом хранения идентификатора записи, соответственно.

Реализованы следующие методы, общие для всех сущностей:
- `getId` - возвращает хранимый идентификатор записи.
- `delete` - удаляет данный объект из базы данных, используя идентификатор и переданные в конструктор название таблицы и ее первичного ключа. Если удаление данного объекта приведет к нарушению ссылочной целостности, то будет выброшено исключение `SQLException`, сообщение которого начинается с `[SQLITE_CONSTRAINT_TRIGGER]`.

Каждый класс сущности организован с учетом следующих соглашений:
- Кроме конструктора `@SelectConstructor` содержится дополнительный, принимающий модель и значения обязательных полей записи, используемых при создании нового объекта (исключая идентификатор), который вызывает основной, передавая в него `-1` в качестве идентификатора записи.
- Содержится метод `save`, который создает новую запись в базе, если идентификатор равен `-1` и обновляет значение идентификатора на основе созданной записи, или же обновляет поля уже имеющейся записи.
- Для каждого поля записи существует getter, для изменяемых полей - setter, который возвращает `this` для возможности организации цепочки, подобной `model.createClient("ФИО").setPhone("1234").save()`.
- Переопределен метод `toString`, возвращающий значение приемлемое для использования в списках.
- Переопределен метод `equals`, проверяющий соответствие идентификаторов записей.

#### Получение сущностей из базы данных

Для каждой сущности в классе `Model` реализованы следующие методы (возможны незначительные отличия для определенных сущностей, которые описаны далее в соответствующих разделах), где `Entity` и `Entities` заменяется на имя конкретной сущности в единственном и множественном числе, соответственно:
- `createEntity` - принимает значения обязательных полей, возвращает новый объект, для которого до вызова `save` нет соответствия в базе данных;
- `getEntityById` - возвращает объект сущности с идентификатором, соответствующим переданному значению;
- `getEntities` - возвращает список, содержащий объекты, соответствующие всем записям для данной сущности.

#### Client - клиент

Данная сущности соответствует клиенту автомастерской и содержит обязательные поля имени и телефона, которые могут быть прочитаны и установлены.

Пример работы с клиентами:
```Java
model.createClient("Test").setPhone("88001234567").save();
model.createClient("Ivan").save();

for(Client c : model.getClients()) System.out.println(c);
```

#### Mark и VehicleModel - марка и модель автомобиля

Данные сущности отвечают за хранение информации о марках и моделях автомобилей, которые обсуживаются в данной автомастерской и для которых имеются в наличии запасные части. Для марки возможно задание названия и получение списка связанных моделей через метод `getVehiclesModels`. Для модели возможно задание названия и года выпуска, получение марки, объект которой необходимо передавать в конструктор.

Пример работы с марками и моделями:
```Java
Mark toyota = model.createMark("Toyota").save();
Mark lada = model.createMark("Lada").save();

model.createVehicleModel(toyota, "Corolla", 2012).save();
model.createVehicleModel(toyota, "Land Cruiser", 2010).save();
model.createVehicleModel(lada, "Priora", 2014).save();

for(Mark m : model.getMarks()) {
  System.out.println(m);
  for(VehicleModel vm : m.getVehiclesModels()) System.out.println("- " + vm);
}
```

#### Service - услуга

Сущность отвечает за хранение информации об услугах, предоставляемых в автомастерской. Возможно задание названия услуги и установка стоимости через метод `setPrice`, который ввиду особенностей реализации не может быть вызван для объекта, которому в базе данных не соответствует запись (после создания объекта через `model.createService` использование `setPrice` допускается только после хотя бы одного вызова `save`).

Для каждой услуги хранится история ее стоимости для корректной обработки заказов, созданных до изменения цены. При вызове `setPrice` в качестве даты и времени изменения устанавливаются текущие. Получение стоимости услуги возможно с использованием двух следующих методов:
- `getPrice()` - возвращает текущую стоимость услуги;
- `getPrice(Date)` - возвращает стоимость, которая была на переданные дату и время.

Пример работы с услугами:
```Java
model.createService("Покраска").save().setPrice(123);
Service service = model.createService("Замена масла").save().setPrice(1);

Thread.sleep(1000); service.setPrice(2);
long time = System.currentTimeMillis();
Thread.sleep(1000); service.setPrice(3);

System.out.println(service.getPrice() + " / " + service.getPrice(new Date(time + 100)));
for(Service o : model.getServices()) System.out.println(o);
```

#### Order - заказ

Cущность отвечает за хранение информации о заказе, связанных с ним услугах и истории изменения статуса. В конструктор требуется передача объектов клиента и модели машины. Возможно задание регистрационного номера автомобиля, а также ориентировочных дат и времени приема и выдачи автомобиля.

Для различия стадий выполнения заказа класс `Order` содержит перечисление `Status` с возможными статусами заказа: `PRELIMINARY` - предварительный, `CONFIRMED` - подтвержденный, `CANCELLED` - отмененный, `INWORK` - в работе, `FINISHED` - завершенный, `CLOSED` - выданный. Все методы, принимающие или возвращающие статус, работают с этим перечислением. В момент сохранения нового заказа ему автоматически присваивается статус `PRELIMINARY`.

Ввиду особенностей реализации, работа со всеми описанными далее методами возможна только для объектов, для которых имеется связанная запись в базе данных (необходимо хотя бы один раз вызвать `save` после `model.createOrder`).

Для работы со связанными услугами предусмотрены следующие методы:
- `void addService(Service)` - добавляет переданную услугу ко списку услуг заказа;
- `List<Service> getServices()` - возвращает список всех услуг, связанных с данным заказом;
- `HashMap<Service, Date> getServicesWithDates()` - возвращает список всех связанных услуг с датой и временем добавления их к данному заказу;
- `void removeService(Service)` - удаляет переданную услугу из заказа;
- `void setServices(List<Service>)` - изменяет список имеющихся услуг заказа на переданный, для услуг, которые уже имелись в списке, дата и время добавления не изменяются.

Пример работы со связанными услугами:
```Java
order.addService(service1); order.addService(service2);

List<Service> services = o.getServices();
services.remove(service1);
o.setServices(services);
```

Для управления статусами заказа у класса реализованы следующие методы:
- `void setStatus(Status)` - устанавливает статус заказа на переданный, если статус равен `CLOSED`, то стоимость заказа вычисляется и запоминается в поле `Finish_cost` базы данных, значение которого в дальнейшем используется вместо вычислений;
- `ArrayList<Pair<String, String>> getHistory()` - возвращает отсортированную по дате историю изменения статуса заказа, каждый элемент которой представляет собой пару из двух строк - названия статуса и текстового представления даты и времени установки данного статуса;
- `Status getCurrentStatus()` - возвращает текущий статус заказа;
- `static Status[] getPossibleStatuses(Status)` - статический метод, возвращающий массив допустимых статусов, в которые можно за один шаг перейти из переданного в качестве аргумента;
- `Status[] getPossibleStatuses()` - метод аналогичный предыдущему, но возвращающий допустимые переходы из текущего статуса заказа, для которого он вызван;
- `Date getRealStartDate()` - возвращает реальную дату создания заказа (момент установки статуса `PRELIMINARY`);
- `Date getRealFinishDate()` - возвращает реальную дату закрытия заказа (момент установки статуса `CLOSED`).

Пример работы со статусами заказа:
```Java
Order o = model.createOrder(client, model, new Date()).setRegistrationNumber("А123BC22").save();
System.out.println(o.getCurrentStatus());

Thread.sleep(100); o.setStatus(Order.Status.CONFIRMED);
Thread.sleep(100); o.setStatus(Order.Status.CLOSED);

System.out.println(o.getCurrentStatus());
for(Pair<String, String> entry : o.getHistory()) System.out.println(entry);
```

Для получения и вычисления стоимости заказа предусмотрены два метода:
- `int getPrice()` - возвращает текущую стоимость заказа. Если статус отличается от `CLOSED`, то данное значение вычисляется, иначе получается из поля `Finish_cost` базы данных;
- `static int getPrice(Order, List<Service>)` - статический метод, используемый для расчета стоимости ещё несформированных заказов, а также пересчета стоимости уже существующих без внесения в них изменений. Первым параметром передается `null` для несформированных заказов или же объект заказа, для которого нужно произвести пересчет. Вторым параметром передается список услуг, для которых производится вычисление стоимости. Если первый параметр не равен `null` и какие-то из услуг уже были ранее добавлены в данный заказ, то при пересчете используется их стоимость на момент изначального добавления к заказу.

Пример вычисления стоимости заказа:
```Java
order.addService(service1); order.addService(service2);
System.out.println(order.getPrice());

Thread.sleep(100); service1.setPrice(500);
System.out.println(order.getPrice());

order.removeService(service1); order.addService(service1);
System.out.println(order.getPrice());

order.setStatus(Order.Status.CLOSED);
System.out.println(order.getPrice());
```

В классе `Order` предусмотрено формирование предварительной сметы и окончательного заказа-наряда через метод `formDocument(boolean)`, параметром которого является флаг - окончательный это документ или нет. Метод сформирует текстовый файл, располагающийся в папке `order` и имеющий название `(НомерЗаказа)-(ИмяКлиента)[-предварительный]`. Возвращаемое значение - `File`, указывающий на созданный документ.

Пример формируемого документа:
```
Заказ №4 / Лещёв Архип Эдуардович / 23.03.2018 16:34 / А123ВС22
                   Предварительная смета

  1. Замена воздушного фильтра                                   200.0 р.
  2. Ремонт радиатора системы охлаждения                         1000.0 р.
  3. Регулировка троса ручного тормоза                           300.0 р.
  4. Установка противотуманных фар                               1500.0 р.

                                                          Итого: 3000.0 р.
```

Работа с заказами в `Model` отличается от описанной в разделе "Получение сущностей из базы данных": отсутствует метод получения заказа по идентификатору, а также присутствует дополнительный `getOrder(Date)`, позволяющий получить список заказов, для которых день предварительного приема или выдачи совпадает с переданным в качестве аргумента.
