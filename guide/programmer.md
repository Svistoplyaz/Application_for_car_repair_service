
# Руководство программиста

Проект представляет собой десктопное приложение, разработанное на Java и использующее встраиваемую СУБД [SQLite] для хранения данных. В качестве зависимостей используются следующие библиотеки:
- [org.xerial:sqlite-jdbc:3.21.0.1](https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc/3.21.0.1) - библиотека SQLite для JDBC (Java DataBase Connectivity);
- [org.apache.commons:commons-lang3:3.0](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3/3.0) - набор утилит, расширяющих возможности стандартной библиотеки Java;
- [io.github.lzh0379:jdatepicker:2.0.3](https://mvnrepository.com/artifact/io.github.lzh0379/jdatepicker/2.0.3) - компоненты Java Swing для выбора даты;
- [com.intellij:annotations:12.0](https://mvnrepository.com/artifact/com.intellij/annotations/12.0) - аннотации для интеграции инспекций кода с [IntelliJ IDEA].

Все зависимости автоматически загружаются средой разработки из репозитория [Maven](https://maven.apache.org/) в папку `.m2`.

[SQLite]: https://www.sqlite.org/index.html
[IntelliJ IDEA]: http://www.jetbrains.com/idea/

#### Сборка проекта

Структура проекта построена для разработки и сборки с использованием IDE [IntelliJ IDEA]. Для открытия проекта необходимо в соответствующем меню (`File > Open`) выбрать корневую папку склонированного репозитория.

Для получения проекта в виде независимого jar файла необходимо выполнить сборку проекта (`Build > Build Project`), после чего исполняемый файл будет доступен по пути `out/artifacts/application/application.jar`.

#### Логическая структура проекта

Программная часть реализованного приложения логически разбита на две основные части - работа с моделью данных и их хранилищем, а также пользовательский интерфейс, каждая из которых может быть рассмотрена отдельно.

## Модель данных и их хранилище

Данная часть разработанного приложения предоставляет интерфейс для работы с базой данных напрямую, а также содержит простейшую реализацию [ORM](https://ru.wikipedia.org/wiki/ORM) (объектно-реляционного отображения), которое позволяет при разработке пользовательского интерфейса работать с объетами языка программирования Java как с сущностями предметной области, не задумываясь о деталях реализации их хранения в базе данных.

Основные классы `Database` и `Model` находятся в пакете `net.web_kot.teamdev.db`, вложенный пакет `entities` содержит класс абстрактной сущности `AbstractEntity`, а также по классу на каждую сущность, работа с которой возможна из пользовательского интерфейса.

### Создание подключения к базе данных и её инициализация

Для создания интерфейса для работы и подключения к базе данных, использующей файл `storage.db` для хранения данных, необходимо вызвать конструктор с необходимым параметром:

```Java
Database database = new Database(new File("storage.db"));
```

Класс `Database` попробует осуществить подключение к данному файлу, используя драйвер SQLite. После чего выполнит активацию поддержки внешних ключей и выполнит запросы, содержащиеся в файле ресурсов `init.sql`, которые отвечают за создание таблиц базы данных и внесение в них начальных значений. Запросы должны быть написаны с учетом того, что они выполняются при каждом подключении, например, создание таблиц должно содержать условие `IF NOT EXISTS`. Отдельные запросы должны быть отделены друг от друга специальным разделителем - отдельной строкой, содержащей `---`.

Пример двух разделенных запросов:

```SQL
CREATE TABLE IF NOT EXISTS Clients (
  PK_Clients INTEGER PRIMARY KEY NOT NULL,
  Name TEXT(100) NOT NULL,
  Phone TEXT(12)
);

---

CREATE TABLE IF NOT EXISTS Service (
  PK_Service INTEGER PRIMARY KEY NOT NULL,
  Name TEXT(50) NOT NULL
);
```

Для включения режима отладки с отображением на стандартный поток вывода всех выполняющихся запросов, необходимо вызвать метод `setDebug(true)` у объекта класса `Database`.

### Форматирование запросов

Для упрощения форматирования запросов у класса `Database` предусмотрен метод `formatQuery(String, Object...)`. Он принимает на вход шаблон SQL-запроса, содержащий спецификации (например, `%d` для чисел или `%s` для строк), и осуществляет замену этих спецификаций на последующие переданные параметры (внутри используется [`Formatter`](https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html) и доступны все его возможности). Также дополнительно производится обертка параметров:
- все `null` объекты подставляются в запрос как `NULL` (обязательно использование спецификации `%s`);
- аргументы типа `String` заключаются в двойные кавычки, содержащиеся в строке кавычки удаляются, удаляются ведущие и концевые пробельные символы.

На выходе данный метод возвращает отформатированную строку, которая может дальше быть передана в запросы. Стандартные методы выполнения запросов в `Database` имеют встроенную поддержку форматирования.

```Java
database.formatQuery(
  "INSERT INTO Table (str1, str2, int1, int2) VALUES (%s, %s, %s, %d)",
  " qwer\"ty", null, Integer.valueOf(10), 12
)
```
```SQL
INSERT INTO Table (str1, str2, int1, int2) VALUES ("qwerty", NULL, 10, 12)
```

### Выполнение запросов

Для выполнения запросов предусмотрены несколько методов, отличающихся возвращаемыми данными, их аргументы совпадают с `formatQuery`. В случае возникновения ошибки при выполнении запроса выбрасывается `SQLException`.
- `exec` - запросы, которые не предусматривают возврат результата;
- `insert` - вставка данных, возвращает идентификатор последней созданной записи;
- `update` - обновление данных, возвращает количество модифицированных записей;
- `select` - получение данных, возвращает [ResultSet](https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html).

Примеры выполнения запросов:
```Java
id = database.insert(
  "INSERT INTO Model (Name, Year, PK_Mark) VALUES (%s, %d, %d)",
  name, year, markId
);
```
```Java
ResultSet result = database.select("SELECT * FROM Status WHERE PK_Order = %d ORDER BY PK_Status ASC", id);
```
```Java
database.exec("DELETE FROM %s WHERE %s = %d", tableName, primaryKey, id);
```

### Модель данных

Основным классом, отвечающим за работу с моделью данных, являтся `Model`. Доступ к объекту данного класса, связанного с определенной базой данных, можно получить с использованием метода `getModel` объекта базы. Данный класс предназначен для доступа к методам для работы с объектами конкретных сущностей базы данных. Из объекта модели можно получить доступ к базе данных для выполнения запросов с использованием метода `db`.

Также он содержит метод `List<T> getList(Class<T>, String)`, который позволят получить список объектов класса `T`, соответствующих записям, полученным в запросе `SELECT`, переданном вторым параметром (встроенное форматирование отсутствует). Класс `T` обязательно должен наследовать `AbstractEntity` и содержать конструктор с аннотацией `@SelectConstructor`. Данный конструктор должен первым параметром принимать `Model`, а порядок и типы последующих параметров должны соответствовать значениям, которые будут возвращены запросом для каждой записи. В случае, если могут быть возращены числовые поля со значением `NULL`, в конструкторе должны в качестве аргуметов использоваться классы `Integer` и `Long` вместо `int` и `long`.

Примеры описания конструктора и выполнения запроса:
```Java
@SelectConstructor
public Client(Model model, int id, String name, String phone) { ... }
```
```Java
List<Client> clients = getList(Client.class, "SELECT PK_Clients, Name, Phone FROM Clients");
```

#### Абстрактная сущность

Каждый класс модели должен наследовать `AbstractEntity`. Конструктор данного класса принимает `Model`, название таблицы и ее первичного ключа для данной сущности. Из наследующих классов доступны `protected` поля `model` и `id`, которые являются переданной в конструктор моделью и местом хранения идентификатора записи, соответственно.

Реализованы следующие методы, общие для всех сущностей:
- `getId` - возвращает хранимый идентификатор записи.
- `delete` - удаляет данный объект из базы данных, используя идентификатор и переданные в конструктор название таблицы и ее первичного ключа. Если удаление данного объекта приведет к нарушению ссылочной целостности, то будет выброшено исключение `SQLException`, сообщение которого начинается с `[SQLITE_CONSTRAINT_TRIGGER]`.

Каждый класс сущности организован с учетом следующих соглашений:
- Кроме конструктора `@SelectConstructor` содержится дополнительный, принимающий модель и значения обязательных полей записи, используемых при создании нового объекта (исключая идентификатор), который вызывает основной, передавая в него `-1` в качестве идентификатора записи.
- Содержится метод `save`, который создает новую запись в базе, если идентификатор равен `-1` и обновляет значение идентификатора на основе созданной записи, или же обновляет поля уже имеющейся записи.
- Для каждого поля записи существует getter, для изменяемых полей - setter, который возвращает `this` для возможности организации цепочки, подобной `model.createClient("ФИО").setPhone("1234").save()`.
- Переопределен метод `toString`, возвращающий значение приемлемое для использования в списках.
- Переопределен метод `equals`, проверяющий соответствие идентификаторов записей.

#### Получение сущностей из базы данных

Для каждой сущности в классе `Model` реализованы следующие методы (возможны незначительные отличия для определенных сущностей, которые описаны далее в соответствующих разделах), где `Entity` и `Entities` заменяется на имя конкретной сущности в единственном и множественном числе, соответственно:
- `createEntity` - принимает значения обязательных полей, возвращает новый объект, для которого до вызова `save` нет соответствия в базе данных;
- `getEntityById` - возвращает объект сущности с идентификатором, соответствующим переданному значению;
- `getEntities` - возвращает список, содержащий объекты, соответствующие всем записям для данной сущности.

#### Client - клиент

Данная сущности соответствует клиенту автомастерской и содержит обязательные поля имени и телефона, которые могут быть прочитаны и установлены.

Пример работы с клиентами:
```Java
model.createClient("Test").setPhone("88001234567").save();
model.createClient("Ivan").save();

for(Client c : model.getClients()) System.out.println(c);
```

#### Mark и VehicleModel - марка и модель автомобиля

Данные сущности отвечают за хранение информации о марках и моделях автомобилей, которые обсуживаются в данной автомастерской и для которых имеются в наличии запасные части. Для марки возможно задание названия и получение списка связанных моделей через метод `getVehiclesModels`. Для модели возможно задание названия и года выпуска, получение марки, объект которой необходимо передавать в конструктор.

Пример работы с марками и моделями:
```Java
Mark toyota = model.createMark("Toyota").save();
Mark lada = model.createMark("Lada").save();

model.createVehicleModel(toyota, "Corolla", 2012).save();
model.createVehicleModel(toyota, "Land Cruiser", 2010).save();
model.createVehicleModel(lada, "Priora", 2014).save();

for(Mark m : model.getMarks()) {
  System.out.println(m);
  for(VehicleModel vm : m.getVehiclesModels()) System.out.println("- " + vm);
}
```

#### Service - услуга

Сущность отвечает за хранение информации об услугах, предоставляемых в автомастерской. Возможно задание названия услуги и установка стоимости через метод `setPrice`, который ввиду особенностей реализации не может быть вызван для объекта, которому в базе данных не соответствует запись (после создания объекта через `model.createService` использование `setPrice` допускается только после хотя бы одного вызова `save`).

Для каждой услуги хранится история ее стоимости для корректной обработки заказов, созданных до изменения цены. При вызове `setPrice` в качестве даты и времени изменения устанавливаются текущие. Получение стоимости услуги возможно с использованием двух следующих методов:
- `getPrice()` - возвращает текущую стоимость услуги;
- `getPrice(Date)` - возвращает стоимость, которая была на переданные дату и время.

Пример работы с услугами:
```Java
model.createService("Покраска").save().setPrice(123);
Service service = model.createService("Замена масла").save().setPrice(1);

Thread.sleep(1000); service.setPrice(2);
long time = System.currentTimeMillis();
Thread.sleep(1000); service.setPrice(3);

System.out.println(service.getPrice() + " / " + service.getPrice(new Date(time + 100)));
for(Service o : model.getServices()) System.out.println(o);
```

#### Order - заказ

Cущность отвечает за хранение информации о заказе, связанных с ним услугах и истории изменения статуса. В конструктор требуется передача объектов клиента и модели машины. Возможно задание регистрационного номера автомобиля, а также ориентировочных дат и времени приема и выдачи автомобиля.

Для различия стадий выполнения заказа класс `Order` содержит перечисление `Status` с возможными статусами заказа: `PRELIMINARY` - предварительный, `CONFIRMED` - подтвержденный, `CANCELLED` - отмененный, `INWORK` - в работе, `FINISHED` - завершенный, `CLOSED` - выданный. Все методы, принимающие или возвращающие статус, работают с этим перечислением. В момент сохранения нового заказа ему автоматически присваивается статус `PRELIMINARY`.

Ввиду особенностей реализации, работа со всеми описанными далее методами возможна только для объектов, для которых имеется связанная запись в базе данных (необходимо хотя бы один раз вызвать `save` после `model.createOrder`).

Для работы со связанными услугами предусмотрены следующие методы:
- `void addService(Service)` - добавляет переданную услугу ко списку услуг заказа;
- `List<Service> getServices()` - возвращает список всех услуг, связанных с данным заказом;
- `HashMap<Service, Date> getServicesWithDates()` - возвращает список всех связанных услуг с датой и временем добавления их к данному заказу;
- `void removeService(Service)` - удаляет переданную услугу из заказа;
- `void setServices(List<Service>)` - изменяет список имеющихся услуг заказа на переданный, для услуг, которые уже имелись в списке, дата и время добавления не изменяются.

Пример работы со связанными услугами:
```Java
order.addService(service1); order.addService(service2);

List<Service> services = o.getServices();
services.remove(service1);
o.setServices(services);
```

Для управления статусами заказа у класса реализованы следующие методы:
- `void setStatus(Status)` - устанавливает статус заказа на переданный, если статус равен `CLOSED`, то стоимость заказа вычисляется и запоминается в поле `Finish_cost` базы данных, значение которого в дальнейшем используется вместо вычислений;
- `ArrayList<Pair<String, String>> getHistory()` - возвращает отсортированную по дате историю изменения статуса заказа, каждый элемент которой представляет собой пару из двух строк - названия статуса и текстового представления даты и времени установки данного статуса;
- `Status getCurrentStatus()` - возвращает текущий статус заказа;
- `static Status[] getPossibleStatuses(Status)` - статический метод, возвращающий массив допустимых статусов, в которые можно за один шаг перейти из переданного в качестве аргумента;
- `Status[] getPossibleStatuses()` - метод аналогичный предыдущему, но возвращающий допустимые переходы из текущего статуса заказа, для которого он вызван;
- `Date getRealStartDate()` - возвращает реальную дату создания заказа (момент установки статуса `PRELIMINARY`);
- `Date getRealFinishDate()` - возвращает реальную дату закрытия заказа (момент установки статуса `CLOSED`).

Пример работы со статусами заказа:
```Java
Order o = model.createOrder(client, model, new Date()).setRegistrationNumber("А123BC22").save();
System.out.println(o.getCurrentStatus());

Thread.sleep(100); o.setStatus(Order.Status.CONFIRMED);
Thread.sleep(100); o.setStatus(Order.Status.CLOSED);

System.out.println(o.getCurrentStatus());
for(Pair<String, String> entry : o.getHistory()) System.out.println(entry);
```

Для получения и вычисления стоимости заказа предусмотрены два метода:
- `int getPrice()` - возвращает текущую стоимость заказа. Если статус отличается от `CLOSED`, то данное значение вычисляется, иначе получается из поля `Finish_cost` базы данных;
- `static int getPrice(Order, List<Service>)` - статический метод, используемый для расчета стоимости ещё несформированных заказов, а также пересчета стоимости уже существующих без внесения в них изменений. Первым параметром передается `null` для несформированных заказов или же объект заказа, для которого нужно произвести пересчет. Вторым параметром передается список услуг, для которых производится вычисление стоимости. Если первый параметр не равен `null` и какие-то из услуг уже были ранее добавлены в данный заказ, то при пересчете используется их стоимость на момент изначального добавления к заказу.

Пример вычисления стоимости заказа:
```Java
order.addService(service1); order.addService(service2);
System.out.println(order.getPrice());

Thread.sleep(100); service1.setPrice(500);
System.out.println(order.getPrice());

order.removeService(service1); order.addService(service1);
System.out.println(order.getPrice());

order.setStatus(Order.Status.CLOSED);
System.out.println(order.getPrice());
```

В классе `Order` предусмотрено формирование предварительной сметы и окончательного заказа-наряда через метод `formDocument(boolean)`, параметром которого является флаг - окончательный это документ или нет. Метод сформирует текстовый файл, располагающийся в папке `order` и имеющий название `(НомерЗаказа)-(ИмяКлиента)[-предварительный]`. Возвращаемое значение - `File`, указывающий на созданный документ.

Пример формируемого документа:
```
Заказ №4 / Лещёв Архип Эдуардович / 23.03.2018 16:34 / А123ВС22
                   Предварительная смета

  1. Замена воздушного фильтра                                   200.0 р.
  2. Ремонт радиатора системы охлаждения                         1000.0 р.
  3. Регулировка троса ручного тормоза                           300.0 р.
  4. Установка противотуманных фар                               1500.0 р.

                                                          Итого: 3000.0 р.
```

Работа с заказами в `Model` отличается от описанной в разделе "Получение сущностей из базы данных": отсутствует метод получения заказа по идентификатору, а также присутствует дополнительный `getOrder(Date)`, позволяющий получить список заказов, для которых день предварительного приема или выдачи совпадает с переданным в качестве аргумента.

## Графический пользовательский интерфейс

Данная часть приложения отвечает за формирование и отображение пользовательского интерфейса и организацию его взаимодействия с описанной ранее моделью данных. Точка входа в приложение расположена в классе `Main` пакета `me.svistoplyas.teamdev`, а все остальные классы размещены во вложенном пакете `graphics`. Интерфейс разработан с использованием компонентов [Java Swing](https://ru.wikipedia.org/wiki/Swing).

### Вспомогательные классы

Для опеспечения работы интерфейса и упрощения процесса разработки в приложении реализованы несколько вспомогательных классов, не завязанных на конкретные сущности предметной области.

#### ImageLoader - загрузчик изображений-ресурсов

Данный класс предназначен для загрузки изображений-ресурсов и их кеширования для ускорения многократных обращений. Является синглтоном, перед началом работы необходимо получить объект с помощью метода `getInstance`. Первичная загрузка или получение из кеша производятся с помощью метода `getImage`, принимающего путь к ресурсу и возвращающего [`BufferedImage`](https://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html). В качестве папки для хранения изображений используется `/images`.

Пример работы с загрузчиком:
```Java
frame.setIconImage(ImageLoader.getInstance().getImage("/images/icon.png"));
```

#### Converter - форматирование цен и дат

Класс предназначен для преобразования цен и дат в строковые представления, отображаемые в пользовательском интерфейсе. Также является синглотоном и содержит метод `getInstance`. Содержит следующие методы:
- `convertPriceToStr` - преобразует цену из количества копеек в строку, содержащую рубли и копейки;
- `convertPriceToStrOnlyRubbles` - аналогично предыдущему, но содержит только рубли;
- `dateToStringWithTime` - преобразование `Date` в строку с датой и временем;
- `dateToStr` - преобразование `Date` в строку с датой.

Примеры использования методов класса:
```Java
Converter c = Converter.getInstance();

System.out.println(c.convertPriceToStr(10020));             // 100,20
System.out.println(c.convertPriceToStrOnlyRubbles(32050));  // 320
System.out.println(c.dateToStrWithTime(new Date()));        // 25/03/2018 14:52
System.out.println(c.dateToStr(new Date()));                // 25/03/2018
```

#### Loading - отображение загрузки

Вспомогательный класс, наследующий `JPanel`, отображающий информацию о том, что идет загрузка, используется во время подгрузки элементов формы, требующих значительного времени на инициализацию.

#### TableModel - представление данных таблиц

Основной формой представления данных в приложении являются таблицы, реализованные на основе `JTable`. Для упрощения представления данных для этих таблиц реализован класс `TableModel`, наследующий [`AbstractTableModel`](https://docs.oracle.com/javase/7/docs/api/javax/swing/table/AbstractTableModel.html). В конструкторе данный класс принимает строковый массив названий столбцов и двухмерный массив объектов - изначальные данные таблицы, первая размерность которого отвечает за количество строк таблицы, а вторая не должна быть меньше количества столбцов и может содержать дополнительные данные в скрытых от отображения ячейках.

Кроме реализации абстрактных методов `getRowCount`, `getColumnCount`, `getColumnName`, `getValueAt` и `getColumnClass`, реализованы следующие дополнительные методы:
- `getValueAt(int)` - возвращает массив объектов, отвечающий за строку таблицы с переданным номером;
- `setData(Object[][])` - замена данных на переданные;
- `addData(Object[])` - добавление строки в конец таблицы;
- `deleteData(int)` - удаление строки с заданным номером.

### Процесс загрузки приложения

В точке входа `Main` устанавливается системный стиль компонентов, стандартная локаль и создается объект класса `Database` с хранением в файле `myfile.db`. Если файл до этого отсутствовал, то в базе данных создаются несколько стандартных записей для демонстрации возможностей. Затем управление передается форме авторизации `LoginForm`.

В конструкторе формы входа создается окно авторизации со списком выбора пользователя (менеджер или владелец) и полем ввода пароля, метод `show` отображает окно. В случае закрытия окна происходит выход из приложения. При правильном вводе пароля для соответствующего пользователя управление передается статическому методу `afterLogin` класса `Main`, получающему в качестве параметра флаг, является ли данный пользователь владельцем.

Метод `afterLogin` создает объект класса `MainFrame`, наследующего `JFrame`, передавая в конструкторе тип пользователя и модель, полученную из созданного ранее подключения к базе данных, а затем отображает это созданное окно.

В конструкторе окна осуществляется построение базового интерфейса - меню для перехода между вкладками, а также `JPanel` для отображение содержимого текущей вкладки. Дополнительно вызывается метод `initViews`, который создает объекты для классов всех доступных вкладок и помещает их в словарь по короткому именю, откуда они извлекаются при открытии вкладок во избежание повторной инициализации. В конце выполняется отображение домашней страницы.

Для упрощения формирования интерфейса реализованы следующие вспомогательные методы:
- `getView(String)` - получение объекта вкладки по короткому имени, заданному в `initViews`;
- `addButton(int, JPanel)` - добавление кпопки в меню на заданном расстоянии от верхнего края и открывающей заданную панель (вкладку);
- `showPanel(JPanel)` - отображение переданной панели в главном окне;
- `showView(AbstractView, boolean)` - метод отображения выбранной вкладки, флаг отвечает за необходимость сброса установленных фильтров *(не реализовано в данной итерации)*. Сначала отображается панель загрузки, затем производится обновление данных на вкладке и после его завершения - отображение вкладки.

### Вкладки

Каждая вкладка приложения отвечает за отображение информации об определенной сущности предметной области и предоставляет инструментарий для работы с ней. Базовая функциональность реализована в наследующем `JPanel` абстрактном классе `AbstractView`, который должны наследовать все классы вкладок. В качестве аргумента в конструктор передается объект главного окна. Все вкладки располагаются в отдельном вложенном пакете `views`.

В конструкторе создается заголовок вкладки, проверяется, имеет ли данный пользователь права на добавление, создание и удаление записей, связанных с данной сущностью, и для разрешенных действий добавляются соответствующие кнопки, создаются обработки нажатий на них. Также создается таблица, инициализируемая с `TableModel`.

Реализован метод обновления данных в таблице `updateTable`, а также определены прототипы следующих методов, которые должны быть реализованы во всех наследующих классах:
- `String[] getColumnNames()` - заголовки столбцов таблицы;
- `Object[][] getData()` - данные для отображения в таблице (формат указан в описании `TableModel`);
- `Object getObject(int)` - получение объекта модели, связанного с переданной строкой таблицы;
- `boolean canAdd()` - может ли текущий пользователь добавлять новые записи;
- `boolean canEdit()` - может ли текущий пользователь редактировать имеющиеся записи;
- `boolean canDelete()` - может ли текущий пользователь удалять записи;
- `void performDelete(int)` - выполняет удаление выбранной записи из представления данных;
- `AbstractEdit getEdit(boolean, Object)` - возвращает форму редактирования переданного объекта или добавления нового, если объект равен `null`. Флаг отвечает за то, редактирование ли это. *(Присутствует стандартная реализиация, возвращающая `null`, что означает отсутствие формы)*.

Во всех классах вкладок реализация данных методов достаточно тривиальна и однотипна. В методе получения данных производится получение объектов из модели и преобразование их полей в соответствующие строковые представления и запись в массив. Метод удаления осуществляет перенаправление на соответстсвующий метод объекта модели, а метод получения формы добавления/редактирования создает новый объект формы и передает в его конструктор главное окно и полученные параметры. Также переопределяется метод `toString`, значение которого используется как заголовок.

Пример простой реализации вкладки со списком клиентов:
```Java
public class ClientsView extends AbstractView {

    public ClientsView(MainFrame _mainFrame) { super(_mainFrame); }

    @Override
    String[] getColumnNames() { return new String[] { "Имя", "Номер телефона" }; }

    @Override
    Object[][] getData() {
        try {
            List<Client> clients = mainFrame.model.getClients();
            Object[][] ans = new Object[clients.size()][];
            for(int i = 0; i < ans.length; i++)
                ans[i] = new Object[] { clients.get(i).getName(), clients.get(i).getPhone() };
            return ans;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    Object getObject(int row) {
        try {
            return mainFrame.model.getClients().get(row);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    boolean canAdd() { return true; }

    @Override
    boolean canEdit() { return true; }

    @Override
    boolean canDelete() { return true; }

    @Override
    void performDelete(int row) throws Exception { mainFrame.model.getClients().get(row).delete(); }

    @Override
    public AbstractEdit getEdit(boolean b, Object o) { return new ClientForm(mainFrame, b, o); }

    @Override
    public String toString() { return "Клиенты"; }

}
```

Отдельными особенностями реализации обладает вкладка домашней страницы `HomeView`, на которой дополнительно отображается календарь для выбора даты, в заголовке кроме названия отображается выбранная дата. А также данные, возвращаемые методом `getData`, зависят от указанной даты.

### Формы редактирования и добавления

Каждая форма добавления и редактирования *(далее просто редактирования)* привязана к конкретной сущности предметной области и должна наследовать класс `AbstractEdit`, который в свою очередь наследует `JDialog`. Все классы форм редактирования расположены во вложенном пакете `editForms`.

Конструктор `AbstractEdit` принимает основное окно, флаг, редактирование ли это, и объект, с которым производится работа. Окно может быть получено в дочерних классах через поле `mainFrame`, а объект через `data`. В конструкторе инициализируются кнопки сохранения изменений и отмены, на них вешаются обработчики событий.

#### Действия при редактировании записи

По нажатию кнопки добавления происходит очистка словаря `baddies`, отвечающего за хранение информации о том, верно ли заполнены поля формы. После чего для каждого компонента из списка `components`, куда с использованием методов `addMark(JComponent, String)` и `addMark(JComponent)` добавляются компоненты, требующие верификации (первый из методов позволяет дополнительно задать тип компонента), выполняется проверка правильности заполнения с использованием метода `isEmptyOrBadlyFilled`, результаты которой заносятся в `baddies`.

Данный метод проверки получает значение компонента, убирает лидирующие и концевые пробельные символы, а затем проверяет строку на непустоту. Для отдельных типов, таких как `Phone` и `Price`, заданных в `addMark` присутствуют дополнительные валидации.

После выполнения проверок выполняется метод `redraw`, отвечающий за отрисовку рядом с компонентами изображений, показывающих на правильность или неправильность заполнения полей. Компоненты изображений кешируются в `marks`.

Если методы `otherValidation` (абстрактный для дополнительных проверок в конкретных формах) и `noBaddies` (возвращающий, все ли проверяемые поля верно заполнены) возвращают `true`, то управление передается абстрактным методам `performEdit` и `performAdd` при редактировании и добавлении, соответственно. После их выполнения диалоговое окно закрывается.

Кроме указанных выше абстрактных `otherValidation`, `performEdit` и `performAdd`, наследующие классы должны также предоставить реализации следующих методов:
- `setSize` - установка размеров окна, вызывается в самом начале инициализации;
- `fillFields` - метод, используемый для заполнения полей формы начальными значениями.

#### ClientForm - клиент

Реализация формы добавления и редактирования клиента достаточно тривиальна. Метод `fillFields` используется только при редактировании записи. Методы `performAdd` и `performEdit` взаимодействуют с объектами модели без дополнительной обработки данных. Дополнительные валидации не применяются.

#### ServiceForm - услуга

В форме добавления и редактирования услуг метод `fillFields` также используется только при редактировании. В методах `fillFields`, `performAdd` и `performEdit` дополнительно производится конвертация стоимости. В качестве дополнительной валидации выполняется проверка наличия записи с таким названием среди имеющихся.

#### OrderForm - заказ

Для обеспечения правильного функционирования формы добавления и редактирования заказов в классе `OrderForm` реализованы следующие методы:
- `fillFields` вызывается всегда при инициализации окна и отвечает не только за заполнение полей значениями при редактировании, но и для заполнения выпадающих списков наборами допустимых значений;
- `performAdd` и `performEdit` выполняют конвертацию дат перед их установкой у объекта, формирование списка выбранных услуг для передачи его в метод `setServices` объекта заказа, а также установку пройденных статусов;
- `setStatuses` последовательно устанавливает статусы заказа, пройденные с момента последнего сохранения, а также вызывает вывод документа соответствующего статусу, если необходимо;
- `otherValidation` конвертирует дату и отвечает за проверку, что ориентировочные даты приема и выдачи позднее текущей, и что дата выдачи позднее даты приема;
- `printFile` - вызывает метод `formDocument` заказа, если для переданного статуса требуется отображение текстового документа, а затем открывает сформированный документ во внешнем текстовом редакторе;
- `changeMark` - вызывается обработчиком изменения списка марок автомобиля, подставляет в список моделей соответствующие данной марке;
- `getDataServiceLeft` - формирует список услуг для таблицы не включенных в данный заказа услуг;
- `getDataServiceRight` - аналогично предыдущему методу, только для включенных услуг;
- ~~`getDataSparesLeft` - для использования в последующих итерациях;~~
- ~~`getDataSparesLeft` - аналогично предыдущему методу;~~
- `setStatusLabel` - установка текущего статуса заказа в соответствии с переданным статусом, а также формирование кнопок перехода к допустимым следующим статусам c назначением обработчиков для них;
- `getStatusTableData` - модель данных для таблицы истории статусов заказа;
- `setCurrentPrice` - установка значения текущей стоимости заказа;
- `getCurrentPrice` - получение текущей стоимости заказа на основе текущего списка выбранных услуг.
